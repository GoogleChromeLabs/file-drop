{"version":3,"file":"filedrop.umd.js","sources":["../index.ts"],"sourcesContent":["/**\n * A decorator that binds values to their class instance.\n * @example\n * class C {\n *   @bind\n *   foo () {\n *     return this;\n *   }\n * }\n * let f = new C().foo;\n * f() instanceof C;    // true\n */\nexport function bind(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  return {\n    // the first time the prototype property is accessed for an instance,\n    // define an instance property pointing to the bound function.\n    // This effectively \"caches\" the bound prototype method as an instance property.\n    get() {\n      const bound = descriptor.value.bind(this);\n      Object.defineProperty(this, propertyKey, {\n        value: bound,\n      });\n      return bound;\n    },\n  };\n}\n\n// tslint:disable-next-line:max-line-length\nfunction firstMatchingItem(list: DataTransferItemList, acceptVal: string): DataTransferItem | undefined {\n  // Split accepts values by ',' then by '/'. Trim everything & lowercase.\n  const accepts = acceptVal.toLowerCase().split(',').map((accept) => {\n    return accept.trim().split('/').map(part => part.trim());\n  }).filter(acceptParts => acceptParts.length === 2); // Filter invalid values\n\n  return Array.from(list).find((item) => {\n    if (item.kind !== 'file') return false;\n\n    // 'Parse' the type.\n    const [typeMain, typeSub] = item.type.toLowerCase().split('/').map(s => s.trim());\n\n    for (const [acceptMain, acceptSub] of accepts) {\n      // Look for an exact match, or a partial match if * is accepted, eg image/*.\n      if (typeMain === acceptMain && (acceptSub === '*' || typeSub === acceptSub)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nfunction getFileData(data: DataTransfer, accept: string): File | undefined {\n  const dragDataItem = firstMatchingItem(data.items, accept);\n  if (!dragDataItem) return;\n\n  return dragDataItem.getAsFile() || undefined;\n}\n\ninterface FileDropEventInit extends EventInit {\n  action: FileDropAccept;\n  file: File;\n}\n\ntype FileDropAccept = 'drop' | 'paste';\n\n// Safari and Edge don't quite support extending Event, this works around it.\nfunction fixExtendedEvent(instance: Event, type: Function) {\n  if (!(instance instanceof type)) {\n    Object.setPrototypeOf(instance, type.prototype);\n  }\n}\n\nexport class FileDropEvent extends Event {\n  private _action: FileDropAccept;\n  private _file: File;\n  constructor(typeArg: string, eventInitDict: FileDropEventInit) {\n    super(typeArg, eventInitDict);\n    fixExtendedEvent(this, FileDropEvent);\n    this._file = eventInitDict.file;\n    this._action = eventInitDict.action;\n  }\n\n  get action() {\n    return this._action;\n  }\n\n  get file() {\n    return this._file;\n  }\n}\n\n/*\n  Example Usage.\n  <file-drop\n    accept='image/*'\n    class='drop-valid|drop-invalid'\n  >\n   [everything in here is a drop target.]\n  </file-drop>\n\n  dropElement.addEventListner('dropfile', (event) => console.log(event.detail))\n*/\nexport class FileDrop extends HTMLElement {\n\n  private _dragEnterCount = 0;\n\n  constructor() {\n    super();\n    this.addEventListener('dragover', event => event.preventDefault());\n    this.addEventListener('drop', this._onDrop);\n    this.addEventListener('dragenter', this._onDragEnter);\n    this.addEventListener('dragend', () => this._reset());\n    this.addEventListener('dragleave', this._onDragLeave);\n    this.addEventListener('paste', this._onPaste);\n  }\n\n  get accept() {\n    return this.getAttribute('accept') || '';\n  }\n\n  set accept(val: string) {\n    this.setAttribute('accept', val);\n  }\n\n  @bind\n  private _onDragEnter(event: DragEvent) {\n    this._dragEnterCount += 1;\n    if (this._dragEnterCount > 1) return;\n\n    // We don't have data, attempt to get it and if it matches, set the correct state.\n    const validDrop: boolean = event.dataTransfer.items.length ?\n      !!firstMatchingItem(event.dataTransfer.items, this.accept) :\n      // Safari doesn't give file information on drag enter, so the best we can do is return valid.\n      true;\n\n    if (validDrop) {\n      this.classList.add('drop-valid');\n    } else {\n      this.classList.add('drop-invalid');\n    }\n  }\n\n  @bind\n  private _onDragLeave() {\n    this._dragEnterCount -= 1;\n    if (this._dragEnterCount === 0) {\n      this._reset();\n    }\n  }\n\n  @bind\n  private _onDrop(event: DragEvent) {\n    event.preventDefault();\n    this._reset();\n    const action = 'drop';\n    const file = getFileData(event.dataTransfer, this.accept);\n    if (file === undefined) return;\n\n    this.dispatchEvent(new FileDropEvent('filedrop', { action, file }));\n  }\n\n  @bind\n  private _onPaste(event: ClipboardEvent) {\n    const action = 'paste';\n    const file = getFileData(event.clipboardData, this.accept);\n    if (file === undefined) return;\n\n    this.dispatchEvent(new FileDropEvent('filedrop', { action, file }));\n  }\n\n  private _reset() {\n    this._dragEnterCount = 0;\n    this.classList.remove('drop-valid');\n    this.classList.remove('drop-invalid');\n  }\n}\n\ncustomElements.define('file-drop', FileDrop);\n"],"names":["target","propertyKey","descriptor","[object Object]","bound","value","bind","this","Object","defineProperty","list","acceptVal","accepts","toLowerCase","split","map","accept","trim","part","filter","acceptParts","length","Array","from","find","item","kind","typeMain","typeSub","type","s","acceptMain","acceptSub","data","dragDataItem","firstMatchingItem","items","getAsFile","undefined","Event","typeArg","eventInitDict","instance","super","FileDropEvent","setPrototypeOf","prototype","_file","file","_action","action","HTMLElement","addEventListener","event","preventDefault","_onDrop","_onDragEnter","_reset","_onDragLeave","_onPaste","getAttribute","val","setAttribute","_dragEnterCount","validDrop","dataTransfer","classList","add","getFileData","dispatchEvent","clipboardData","remove","customElements","define","FileDrop"],"mappings":"8fAYqBA,EAAaC,EAAqBC,GACrD,OAIEC,MACE,MAAMC,EAAQF,EAAWG,MAAMC,KAAKC,MAIpC,OAHAC,OAAOC,eAAeF,KAAMN,GAC1BI,MAAOD,IAEFA,IAMb,WAA2BM,EAA4BC,GAErD,MAAMC,EAAUD,EAAUE,cAAcC,MAAM,KAAKC,IAAKC,GAC/CA,EAAOC,OAAOH,MAAM,KAAKC,IAAIG,GAAQA,EAAKD,SAChDE,OAAOC,GAAsC,IAAvBA,EAAYC,QAErC,OAAOC,MAAMC,KAAKb,GAAMc,KAAMC,IAC5B,GAAkB,SAAdA,EAAKC,KAAiB,OAAO,EAGjC,MAAOC,EAAUC,GAAWH,EAAKI,KAAKhB,cAAcC,MAAM,KAAKC,IAAIe,GAAKA,EAAEb,QAE1E,IAAK,MAAOc,EAAYC,KAAcpB,EAEpC,GAAIe,IAAaI,IAA6B,MAAdC,GAAqBJ,IAAYI,GAC/D,OAAO,EAGX,OAAO,IAIX,WAAqBC,EAAoBjB,GACvC,MAAMkB,EAAeC,EAAkBF,EAAKG,MAAOpB,GACnD,GAAKkB,EAEL,OAAOA,EAAaG,kBAAeC,kBAiBFC,MAGjCpC,YAAYqC,EAAiBC,GAT/B,IAA0BC,EAAiBb,EAUvCc,MAAMH,EAASC,IAVOC,EAWLnC,gBAXsBsB,EAWhBe,IATvBpC,OAAOqC,eAAeH,EAAUb,EAAKiB,WAUrCvC,KAAKwC,MAAQN,EAAcO,KAC3BzC,KAAK0C,QAAUR,EAAcS,OAG/BA,aACE,OAAO3C,KAAK0C,QAGdD,WACE,OAAOzC,KAAKwC,uBAecI,YAI5BhD,cACEwC,QAHMpC,qBAAkB,EAIxBA,KAAK6C,iBAAiB,WAAYC,GAASA,EAAMC,kBACjD/C,KAAK6C,iBAAiB,OAAQ7C,KAAKgD,SACnChD,KAAK6C,iBAAiB,YAAa7C,KAAKiD,cACxCjD,KAAK6C,iBAAiB,cAAiB7C,KAAKkD,UAC5ClD,KAAK6C,iBAAiB,YAAa7C,KAAKmD,cACxCnD,KAAK6C,iBAAiB,QAAS7C,KAAKoD,UAGtC3C,aACE,OAAOT,KAAKqD,aAAa,WAAa,GAGxC5C,WAAW6C,GACTtD,KAAKuD,aAAa,SAAUD,GAItB1D,aAAakD,GAEnB,GADA9C,KAAKwD,iBAAmB,EACpBxD,KAAKwD,gBAAkB,EAAG,OAG9B,MAAMC,GAAqBX,EAAMY,aAAa7B,MAAMf,UAChDc,EAAkBkB,EAAMY,aAAa7B,MAAO7B,KAAKS,QAKnDT,KAAK2D,UAAUC,IADbH,EACiB,aAEA,gBAKf7D,eACNI,KAAKwD,iBAAmB,EACK,IAAzBxD,KAAKwD,iBACPxD,KAAKkD,SAKDtD,QAAQkD,GACdA,EAAMC,iBACN/C,KAAKkD,SACL,MACMT,EAAOoB,EAAYf,EAAMY,aAAc1D,KAAKS,aACrCsB,IAATU,GAEJzC,KAAK8D,cAAc,IAAIzB,EAAc,YAAcM,OAJpC,OAI4CF,KAAAA,KAIrD7C,SAASkD,GACf,MACML,EAAOoB,EAAYf,EAAMiB,cAAe/D,KAAKS,aACtCsB,IAATU,GAEJzC,KAAK8D,cAAc,IAAIzB,EAAc,YAAcM,OAJpC,QAI4CF,KAAAA,KAGrD7C,SACNI,KAAKwD,gBAAkB,EACvBxD,KAAK2D,UAAUK,OAAO,cACtBhE,KAAK2D,UAAUK,OAAO,oBAjDvBjE,uCAkBAA,uCAQAA,kCAWAA,gCAgBHkE,eAAeC,OAAO,YAAaC"}